Bardia's Password Manager and Checker

Video Demo: https://www.youtube.com/watch?v=N6hnCyyvmKY

Description:
This project is a CLI application written in Python for the final project of Harvard's CS50P. It is a two-in-one security utility, offering users both a robust Password Strength Checker and a useful Password Manager. Its primary purpose is to improve password security awareness in users by offering real-time, actionable feedback on the quality of passwords and, in the meantime, a simple system to save credentials for online services. The application is very intuitive and straightforward to use, with navigation entirely via on-screen menus and prompts, making it simple to utilize even for non-technical users.

The operation of the program is split into two distinct modules, which are invoked from a shared main menu. The Password Strength Checker, the first module, allows any password to be entered by a user and receive a comprehensive analysis. The analysis includes a rating out of five for strength, which is based on five critical criteria: minimum length (12 characters), and the inclusion of uppercase letters, lowercase letters, numbers, and special characters. In addition to this local analysis, the tool also integrates with the "Have I Been Pwned" public API. It securely checks if the password entered has ever been exposed in data breaches that are publicly known, giving the user essential context about its real-world security. This is done through the k-Anonymity model. The application hashes the password using the SHA-1 algorithm, then sends only the first five characters of the hash to the API. This ensures that the user's full password is never sent over the network, a useful privacy precaution.

The second module is a lightweight Password Manager. This module allows users to perform full CRUD (Create, Read, Update, Delete) actions on their login information. The user is able to add, edit, and remove entries with a service name, username, and password. All of this is stored locally in a passwords.json file, which acts as the program's persistent database so the user's data can survive sessions. For backup and convenience, the manager also has the functionality to export all the stored credentials into a human-readable passwords_export.csv file. A key design choice for this project was keeping things simple and providing immediate control to the user. An earlier version of the design included an encryption layer using the cryptography library. To provide direct human-readable access and editing capability to the passwords.json file, and to keep the project focused on the core activities of API interaction and data handling, the encryption layer was intentionally removed. While this makes the password storage insecure for a production, real-world application, it was a conscious educational decision to fit within the scope and specific user requirements of this academic project, demonstrating an understanding of the trade-offs involved in software development.
File Breakdown
The project is divided into two main files, each with a distinct and important purpose:

project.py
This is the core engine of the application. Contains all the functional logic, from user interface through data management to external API communication.
There are two places where comments are especially necessary:
main(): The entry point for the program. Displays the main menu, from which the user can go on to the strength checker, password manager, or exit the application. Acts as the fulcrum of the user experience.
run_strength_checker() & run_password_manager(): These two functions act as controllers for the two main features, handling the respective sub-menus and workflow for each module, and hence keeping the main function clean and readable.
check_password_strength(password): One of the project's most important testable functions. It takes a password string and checks it against five security requirements using regular expressions (re module). It returns a numerical score and a list of feedback strings, providing brief suggestions for improvement.
check_pwned_api(password): The second primary testable function securely interacts with the HaveIBeenPwned API. It uses the hashlib library to create a SHA-1 hash of the password and then invokes the API with a partial hash to query breaches in a way that preserves user privacy. It handles the requests call and parses the text response.
format_for_csv(passwords_dict): The third primary testable function. Its sole responsibility is to transform the in-memory dictionary of passwords into a list of lists, a data structure perfect for the csv library's writerows method. Isolating the data formatting from the file I/O makes the code more modular and easier to test.
Helper Functions (load_passwords, save_passwords, add_password, edit_password, remove_password, etc.): These functions encapsulate the file I/O operations (reading from and writing to passwords.json) and the actual CRUD logic for the password manager. Having these operations encapsulated prevents code duplication and simplifies the logic in the main manager loop.

test_project.py
This file is tasked with ensuring the reliability and correctness of project.py's core logic through automated unit testing with the pytest framework.
Testing Strategy: The tests are designed to check the correctness of the three main custom functions under various conditions, such as expected inputs, boundary cases, and invalid data.
test_check_password_strength(): This test suite ensures that the function correctly scores both strong passwords (with a perfect score and no feedback) and a variety of weak passwords. Each weak password test checks a specific failure, like not having an uppercase letter or being too short, to ensure the correctness of the feedback mechanism.
test_check_pwned_api(): This is a bit of a more complicated test that uses unittest.mock.patch to "mock" the requests.get call. This is one of those fundamental design choices when testing software professionally. By mocking out the API's response, we're left with a test that is not only fast but also completely independent of externalities like network connectivity or if the API is even functional. This isolation ensures we are testing our code's logic, and our code's logic only, which is the primary goal of a unit test.
test_format_for_csv(): These tests ensure the CSV formatting function is working correctly. It's tested with a normal, populated password dictionary, with an empty dictionary (a useful edge case), and is also tested to ensure it correctly raises a TypeError when given invalid input, ensuring the function's strength and type-checking.
